# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T11:58:59+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Header, Path, Query

from models import (
    ApiDataentitiesDataEntityNameDocumentsIdVersionsGetResponse,
    CreateUpdateAddressRequests,
    CreateUpdateProfileRequests,
    DocumentRequest,
    DocumentResponse,
    Getversion,
    PutindicesRequest,
    SaveschemabynameRequest,
    UsingFieldsAll,
)

app = MCPProxy(
    contact={},
    description="# ATTENTION: **This version isn't compliant with data entities of old version (e.g. CL and AD). It's possible to use this configuration only to new data entities.**\r\n\r\n\r\n## Welcome!\r\n\r\nVTEX Master Data is an easy-to-use, secure, fast, scalable and extensible repository. On it you can create your own Entities, store data and consult directly from the storefront or use it to store info for some external integration.\r\n\r\nThere are internal VTEX modules that use VTEX Master Data as data repository. We have the VTEX Customer Service, VTEX Profile System and VTEX InStore, for example. It is also used by other internal services.\r\n\r\nThere are two ways to use Master Data:\r\n\r\n1. Directly from the storefront\r\n2. External integration\r\n\r\n### Directly from the storefront\r\n\r\nIf your scenario is to be used inside the storefront, be aware of the following observations:\r\n\r\n1. Use the storefront host to query or store information to avoid **CORS**;\r\n2. Configure which information should be public and which shouldn't, inside the JSON Schema of the Data Entity;\r\n3. Do not create query loops (the storefront may be affected with Throttling and apis may be turned off as a security protection);\r\n4. Never add via JS any type of authentication key (x-vtex-api-appkey or x-vtex-api-apptoken);\r\n\r\n**It's important to avoid CORS using the relative path**\r\n\r\n### External Integration\r\n\r\nIf your scenario is to perform external integration, such as migrating client data from another service, be aware of the following observations:\r\n\r\n1. Use the host ```{{accountName}}.vtexcommercestable.com.br```;\r\n2. Use the authentication keys (x-vtex-api-appkey ou x-vtex-api-apptoken);\r\n\r\n### Most used attributes listed here\r\n\r\n| Name | Description |\r\n| -------- | -------- |\r\n| accountName | Account name in VTEX License Manager |\r\n| name | Data Entity name |\r\n| schema | JSON Schema of a Data Entity |\r\n| id | Identifier of a document |\r\n| x-vtex-api-appKey | User key |\r\n| x-vtex-api-appToken | User token |",
    title='Master Data API - v2',
    version='1.0',
    servers=[
        {'url': 'https://vtex.local'},
        {
            'description': 'VTEX server url',
            'url': 'https://{accountName}.{environment}.com.br',
            'variables': {
                'accountName': {
                    'default': '{accountName}',
                    'description': 'Name of the VTEX account. Used as part of the URL',
                },
                'environment': {
                    'default': '{environment}',
                    'description': 'Environment to use. Used as part of the URL.',
                },
            },
        },
    ],
)


@app.post(
    '/api/dataentities/Address/documents',
    description=""" Creates new customer address. 

> You can use this request to create customer addresses according to any `AD` schema. Because of this, you are not restricted to using the fields exemplified below in your requests. But you should be aware of the fields allowed or required for the schemas you are using. Learn more about how to use [Master Data v2 schemas](https://developers.vtex.com/vtex-rest-api/docs/master-data-schema-lifecycle). """,
    tags=['customer_address_handling'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def create_new_customer_address(
    content__type: str = Header(..., alias='Content-Type'),
    accept: str = Header(..., alias='Accept'),
    field_schema: Optional[str] = Query(None, alias='_schema'),
    body: CreateUpdateAddressRequests = ...,
):
    """
    Create new customer address
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/dataentities/Address/documents/{id}',
    description=""" Deletes a customer address. """,
    tags=['customer_address_handling'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def delete_customer_address(
    content__type: str = Header(..., alias='Content-Type'),
    accept: str = Header(..., alias='Accept'),
    id: str = ...,
):
    """
    Delete customer address
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/api/dataentities/Address/documents/{id}',
    description=""" Partially updates a customer address.

> You can use this request to update customer addresses according to any `AD` schema. Because of this, you are not restricted to using the fields exemplified below in your requests. But you should be aware of the fields allowed or required for the schemas you are using. Learn more about how to use [Master Data v2 schemas](https://developers.vtex.com/vtex-rest-api/docs/master-data-schema-lifecycle). """,
    tags=['customer_address_handling', 'customer_profile_handling'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def update_customer_address(
    field_schema: Optional[str] = Query(None, alias='_schema'),
    content__type: str = Header(..., alias='Content-Type'),
    accept: str = Header(..., alias='Accept'),
    id: str = ...,
    body: CreateUpdateAddressRequests = ...,
):
    """
    Update customer address
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/dataentities/Client/documents',
    description=""" Creates new customer profile.

> You can use this request to create customer profiles according to any `CL` schema. Because of this, you are not restricted to using the fields exemplified below in your requests. But you should be aware of the fields allowed or required for the schemas you are using. Learn more about how to use [Master Data v2 schemas](https://developers.vtex.com/vtex-rest-api/docs/master-data-schema-lifecycle). """,
    tags=['customer_profile_handling'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def create_new_customer_profilev2(
    content__type: str = Header(..., alias='Content-Type'),
    accept: str = Header(..., alias='Accept'),
    field_schema: Optional[str] = Query(None, alias='_schema'),
    body: CreateUpdateProfileRequests = ...,
):
    """
    Create new customer profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/dataentities/Client/documents/{id}',
    description=""" Deletes a customer profile. """,
    tags=['customer_profile_handling'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def delete_customer_profile(
    content__type: str = Header(..., alias='Content-Type'),
    accept: str = Header(..., alias='Accept'),
    id: str = ...,
):
    """
    Delete customer profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/api/dataentities/Client/documents/{id}',
    description=""" Partially updates a customer profile.

> You can use this request to update customer profiles according to any `CL` schema. Because of this, you are not restricted to using the fields exemplified below in your requests. But you should be aware of the fields allowed or required for the schemas you are using. Learn more about how to use [Master Data v2 schemas](https://developers.vtex.com/vtex-rest-api/docs/master-data-schema-lifecycle). """,
    tags=['customer_profile_handling'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def update_customer_profile(
    field_schema: Optional[str] = Query(None, alias='_schema'),
    content__type: str = Header(..., alias='Content-Type'),
    accept: str = Header(..., alias='Accept'),
    id: str = ...,
    body: CreateUpdateProfileRequests = ...,
):
    """
    Update customer profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/api/dataentities/{dataEntityName}/documents',
    description=""" This request allows you to partially update a document corresponding to a given data entity.

> You can use this request to create documents for any given data entity. Because of this, you are not restricted to using the fields exemplified below in your requests. But you should be aware of the fields allowed or required for each document you wish to update.

## Example use cases

### Client profile

In order to create a customer profile's `phone` and `isNewsletterOptIn` fields, choose the `CL` data entity and send a request similar to this:

PATCH
```
https://examplestore.vtexcommercestable.com.br/api/dataentities/Client/documents
```

Request body
```json
{
    "phone": "+12025550195",
    "isNewsletterOptIn": false
 }
```

### Client address

In order to update the `receiverName` of an existing address, the data entity is `AD` and the request would look like this:

PATCH
```
https://examplestore.vtexcommercestable.com.br/api/dataentities/Address/documents
```

Request body
```json
{
    "receiverName": "Lois Lane"
}
``` """,
    tags=['document_crud_operations', 'data_schema_management'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def createorupdatepartialdocument(
    data_entity_name: str = Path(..., alias='dataEntityName'),
    field_schema: Optional[str] = Query(None, alias='_schema'),
    content__type: str = Header(..., alias='Content-Type'),
    accept: str = Header(..., alias='Accept'),
    body: DocumentRequest = ...,
):
    """
    Create partial document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/dataentities/{dataEntityName}/documents',
    description=""" This request allows you to create a new document corresponding to a given data entity. For example, you can create a new customer profile or address.

> You can use this request to create documents for any given data entity. Because of this, you are not restricted to using the fields exemplified below in your requests. But you should be aware of the fields allowed or required for each document you wish to create.

## Example use cases

### Client profile

In order to create a new customer profile, choose the `CL` data entity and send a request similar to this:

POST
```
https://examplestore.vtexcommercestable.com.br/api/dataentities/Client/documents
```

Request body
```json
{
    "email": "clark.kent@examplemail.com",
    "firstName": "Clark",
    "lastName": "Kent",
    "phone": "+12025550195",
    "documentType": "CPF",
    "document": "12345678900"
    "isCorporate": false,
    "isNewsletterOptIn": false,
    "localeDefault": "en-US"
 }
```

### Client address

For a new address, the data entity is `AD` and the request would look like this:

POST
```
https://examplestore.vtexcommercestable.com.br/api/dataentities/Address/documents
```

Request body
```json
{
    "addressName": "My House",
    "addressType": "residential",
    "city": "Metropolis",
    "complement": "",
    "country": "USA",
    "postalCode": "11375",
    "receiverName": "Clark Kent",
    "reference": null,
    "state": "MP",
    "street": "Baker Street",
    "neighborhood": "Upper east side",
    "number": "21",
    "userId": "7e03m794-a33a-11e9-84rt6-0adfa64s5a8e"
}
``` """,
    tags=['document_crud_operations', 'data_schema_management'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def createnewdocument(
    content__type: str = Header(..., alias='Content-Type'),
    accept: str = Header(..., alias='Accept'),
    data_entity_name: str = Path(..., alias='dataEntityName'),
    field_schema: Optional[str] = Query(None, alias='_schema'),
    body: DocumentRequest = ...,
):
    """
    Create new document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/dataentities/{dataEntityName}/documents/{id}',
    description=""" It allows to delete a document. """,
    tags=['document_crud_operations'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def deletedocument(
    data_entity_name: str = Path(..., alias='dataEntityName'),
    content__type: str = Header(..., alias='Content-Type'),
    accept: str = Header(..., alias='Accept'),
    id: str = ...,
):
    """
    Delete document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/dataentities/{dataEntityName}/documents/{id}',
    description=""" Gets document by ID.


> Assign the `_fields` parameter in the query string to retrieve the desired fields. If you want to return all the fields use `_fields=_all`. """,
    tags=['document_crud_operations'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def getdocument(
    data_entity_name: str = Path(..., alias='dataEntityName'),
    content__type: str = Header(..., alias='Content-Type'),
    accept: str = Header(..., alias='Accept'),
    id: str = ...,
):
    """
    Get document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/api/dataentities/{dataEntityName}/documents/{id}',
    description=""" This request allows you to partially update a document corresponding to a given data entity. For example, you can update some fields of a customer profile or address.

> You can use this request to update documents for any given data entity. Because of this, you are not restricted to using the fields exemplified below in your requests. But you should be aware of the fields allowed or required for each document you wish to update.

## Example use cases

### Client profile

In order to update a customer profile's `phone` and `isNewsletterOptIn` fields, choose the `CL` data entity and send a request similar to this:

PATCH
```
https://examplestore.vtexcommercestable.com.br/api/dataentities/Client/documents/123456789abc
```

Request body
```json
{
    "phone": "+12025550195",
    "isNewsletterOptIn": false
 }
```

### Client address

In order to update the `receiverName` of an existing address, the data entity is `AD` and the request would look like this:

PATCH
```
https://examplestore.vtexcommercestable.com.br/api/dataentities/Address/documents/123456789abc
```

Request body
```json
{
    "receiverName": "Lois Lane"
}
``` """,
    tags=['document_crud_operations', 'data_schema_management'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def updatepartialdocument(
    data_entity_name: str = Path(..., alias='dataEntityName'),
    field_where: Optional[str] = Query(None, alias='_where'),
    field_schema: Optional[str] = Query(None, alias='_schema'),
    accept: str = Header(..., alias='Accept'),
    id: str = ...,
    body: DocumentRequest = ...,
):
    """
    Update partial document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/api/dataentities/{dataEntityName}/documents/{id}',
    description=""" Update an existing document corresponding to a given data entity. For example, you can update a customer profile or address.

> You can use this request to update documents in any given data entity. Because of this, you are not restricted to using the fields exemplified below in your requests. But you should be aware of the fields allowed or required for each document you wish to update.

## Example use cases

### Client profile

In order to update an existing customer profile, choose the `CL` data entity and send a request similar to this:

PUT
```
https://examplestore.vtexcommercestable.com.br/api/dataentities/Client/documents/123456789abc
```

Request body
```json
{
    "email": "clark.kent@examplemail.com",
    "firstName": "Clark",
    "lastName": "Kent",
    "phone": "+12025550195",
    "documentType": "CPF",
    "document": "12345678900"
    "isCorporate": false,
    "isNewsletterOptIn": false,
    "localeDefault": "en-US"
 }
```

### Client address

To update an address, the data entity is `AD` and the request would look like this:

PUT
```
https://examplestore.vtexcommercestable.com.br/api/dataentities/Address/documents/123456789abc
```

Request body
```json
{
    "addressName": "My House",
    "addressType": "residential",
    "city": "Metropolis",
    "complement": "",
    "country": "USA",
    "postalCode": "11375",
    "receiverName": "Clark Kent",
    "reference": null,
    "state": "MP",
    "street": "Baker Street",
    "neighborhood": "Upper east side",
    "number": "21",
    "userId": "7e03m794-a33a-11e9-84rt6-0adfa64s5a8e"
}
``` """,
    tags=['document_crud_operations', 'data_schema_management'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def updateentiredocument(
    data_entity_name: str = Path(..., alias='dataEntityName'),
    field_where: Optional[str] = Query(None, alias='_where'),
    field_schema: Optional[str] = Query(None, alias='_schema'),
    accept: str = Header(..., alias='Accept'),
    id: str = ...,
    body: DocumentRequest = ...,
):
    """
    Update entire document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/dataentities/{dataEntityName}/documents/{id}/clusters',
    description=""" Check if a document is present in one or more clusters (specific set of field values).

> There is a limit of five rules per request. """,
    tags=['document_crud_operations'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def validatedocumentbyclusters(
    data_entity_name: str = Path(..., alias='dataEntityName'),
    accept: str = Header(..., alias='Accept'),
    id: str = ...,
    body: str = ...,
):
    """
    Validate document by clusters
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/dataentities/{dataEntityName}/documents/{id}/versions',
    description=""" Allows to list the versions of a document. """,
    tags=['document_version_control'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def listversions(
    data_entity_name: str = Path(..., alias='dataEntityName'),
    content__type: str = Header(..., alias='Content-Type'),
    accept: str = Header(..., alias='Accept'),
    id: str = ...,
    load: Optional[bool] = True,
    fields: Optional[str] = 'id,dataEntityId,isNewsletterOptIn,createdBy',
):
    """
    List versions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/dataentities/{dataEntityName}/documents/{id}/versions/{versionId}',
    description=""" Returns the version of a document. """,
    tags=['document_version_control'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def getversion(
    data_entity_name: str = Path(..., alias='dataEntityName'),
    content__type: str = Header(..., alias='Content-Type'),
    accept: str = Header(..., alias='Accept'),
    id: str = ...,
    version_id: str = Path(..., alias='versionId'),
):
    """
    Get version
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/api/dataentities/{dataEntityName}/documents/{id}/versions/{versionId}',
    description=""" Updates document with version values. """,
    tags=['document_version_control'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def putversion(
    data_entity_name: str = Path(..., alias='dataEntityName'),
    content__type: str = Header(..., alias='Content-Type'),
    accept: str = Header(..., alias='Accept'),
    id: str = ...,
    version_id: str = Path(..., alias='versionId'),
):
    """
    Put version
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/dataentities/{dataEntityName}/indices',
    description=""" Returns the list of indices by data entity. """,
    tags=['index_operations'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def getindices(
    data_entity_name: str = Path(..., alias='dataEntityName'),
    content__type: str = Header(..., alias='Content-Type'),
):
    """
    Get indices
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/api/dataentities/{dataEntityName}/indices',
    description=""" Create an index. """,
    tags=['index_operations'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def putindices(
    data_entity_name: str = Path(..., alias='dataEntityName'),
    body: PutindicesRequest = ...,
):
    """
    Put indices
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/dataentities/{dataEntityName}/indices/{index_name}',
    description=""" Delete an index. """,
    tags=['index_operations'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def deleteindexbyname(
    data_entity_name: str = Path(..., alias='dataEntityName'),
    content__type: str = Header(..., alias='Content-Type'),
    index_name: str = ...,
):
    """
    Delete index by name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/dataentities/{dataEntityName}/indices/{index_name}',
    description=""" Returns an index. """,
    tags=['index_operations'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def getindexbyname(
    data_entity_name: str = Path(..., alias='dataEntityName'),
    content__type: str = Header(..., alias='Content-Type'),
    index_name: str = ...,
):
    """
    Get index by name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/dataentities/{dataEntityName}/schemas',
    description=""" Return the schemas saved. """,
    tags=['data_schema_management'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def getschemas(
    data_entity_name: str = Path(..., alias='dataEntityName'),
    content__type: str = Header(..., alias='Content-Type'),
):
    """
    Get schemas
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/dataentities/{dataEntityName}/schemas/{schemaName}',
    description=""" Deletes an existing schema for a given data entity. """,
    tags=['data_schema_management'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def deleteschemabyname(
    content__type: str = Header(..., alias='Content-Type'),
    data_entity_name: str = Path(..., alias='dataEntityName'),
    schema_name: str = Path(..., alias='schemaName'),
):
    """
    Delete schema by name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/dataentities/{dataEntityName}/schemas/{schemaName}',
    description=""" Returns an existing schema for a given data entity. """,
    tags=['data_schema_management'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def getschemabyname(
    data_entity_name: str = Path(..., alias='dataEntityName'),
    content__type: str = Header(..., alias='Content-Type'),
    schema_name: str = Path(..., alias='schemaName'),
):
    """
    Get schema by name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/api/dataentities/{dataEntityName}/schemas/{schemaName}',
    description=""" Creates or edits a data entity schema. Learn more about [Master Data schemas](https://developers.vtex.com/vtex-rest-api/docs/master-data-schema-lifecycle)

> Note that if you send a `schemaName` that does not exist for that data entity, this request will create it.

This request can also be used to [create or edit Master Data v2 triggers](https://developers.vtex.com/vtex-rest-api/docs/setting-up-triggers-in-master-data-v2). """,
    tags=['data_schema_management'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def saveschemabyname(
    data_entity_name: str = Path(..., alias='dataEntityName'),
    schema_name: str = Path(..., alias='schemaName'),
    body: SaveschemabynameRequest = ...,
):
    """
    Save schema by name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/dataentities/{dataEntityName}/scroll',
    description=""" In the first request, the `X-VTEX-MD-TOKEN` token will be returned in the header. This token must be passed to the next request in the query string `_token` parameter. The token has a timeout of 10 minutes, which refreshes after each request.

After the token is obtained it is no longer necessary to send the filter or document size per page parameters. You only need to resend the token until the document collection is empty.


> Avoid sending too many requests with wildcards (`*`) in the search parameters or that use the `keyword` parameter. This may lead to this endpoint being temporarily blocked for your account. If this happens you will receive an error with status code `429`.

## Request examples

First request:
```
/dataentities/Client/scroll?isCluster=true&_size=250&_fields=email,firstName
```

Retrieve the token in the header `X-VTEX-MD-TOKEN` from the first request's response and use it to make the next requests.

Subsequent requests:
```
/dataentities/Client/scroll?_token={tokenValueExample}
``` """,
    tags=['document_crud_operations', 'document_search_functionality'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def scrolldocuments(
    data_entity_name: str = Path(..., alias='dataEntityName'),
    content__type: str = Header(..., alias='Content-Type'),
    accept: str = Header(..., alias='Accept'),
    field_token: Optional[str] = Query('{tokenValueExample}', alias='_token'),
    r_e_s_t__range: str = Header(..., alias='REST-Range'),
    field_fields: Optional[str] = Query('email,firstName,document', alias='_fields'),
    field_where: Optional[str] = Query(None, alias='_where'),
    field_schema: Optional[str] = Query(None, alias='_schema'),
    field_keyword: Optional[str] = Query(None, alias='_keyword'),
    field_sort: Optional[str] = Query('firstName ASC', alias='_sort'),
):
    """
    Scroll documents
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/dataentities/{dataEntityName}/search',
    description=""" Retrieves documents' information, while choosing which fields will be returned and filtering documents by specific fields.

> The response header `REST-Content-Range` indicates the total amount of results for that specific search. For example, it may return `resources 0-100/136108`, which indicates it has returned results from 0 to 100 of a total 136108.

Below you can see some query examples and learn more about each query parameter.


> Avoid sending too many requests with wildcards (`*`) in the search parameters or that use the `keyword` parameter. This may lead to this endpoint being temporarily blocked for your account. If this happens you will receive an error with status code `503`.

## Query examples

### Simple filter

```
/dataentities/Client/search?email=my@email.com
```

### Complex filter

```
/dataentities/Client/search?_where=(firstName=Jon OR lastName=Smith) OR (createdIn between 2001-01-01 AND 2016-01-01)
```

### Date Range

```
/dataentities/Client/search?_where=createdIn between 2001-01-01 AND 2016-01-01
```

### Range numeric fields

```
/dataentities/Client/search?_where=age between 18 AND 25
```

### Partial filter

```
/dataentities/Client/search?firstName=*Maria*
```

### Filter for null values

```
/dataentities/Client/search?_where=firstName is null
```

### Filter for non-null values

```
/dataentities/Client/search?_where=firstName is not null
```

### Filter for difference
```
/dataentities/Client/search?_where=firstName<>maria
```

### Filter greater than or less than
```
/dataentities/Client/search?_where=number>5
/dataentities/Client/search?_where=date<2001-01-01
``` """,
    tags=['document_crud_operations', 'document_search_functionality'],
    security=[
        APIKeyHeader(name="X-VTEX-API-AppKey"),
        APIKeyHeader(name="X-VTEX-API-AppToken"),
    ],
)
def searchdocuments(
    data_entity_name: str = Path(..., alias='dataEntityName'),
    content__type: str = Header(..., alias='Content-Type'),
    accept: str = Header(..., alias='Accept'),
    r_e_s_t__range: str = Header(..., alias='REST-Range'),
    field_fields: Optional[str] = Query('email,firstName,document', alias='_fields'),
    field_where: Optional[str] = Query(None, alias='_where'),
    field_schema: Optional[str] = Query(None, alias='_schema'),
    field_keyword: Optional[str] = Query(None, alias='_keyword'),
    field_sort: Optional[str] = Query('firstName ASC', alias='_sort'),
):
    """
    Search documents
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
